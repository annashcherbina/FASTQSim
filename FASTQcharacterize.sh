#!/bin/bash


#This class finds the read length histogram, quality score values, insertion/deletion/mutation rates, and other parameters 
#for an input fastq file 
# @author        Anna Shcherbina (mailto: anna.shcherbina@ll.mit.edu)
# Copyrigth 2013 Anna Shcherbina 
#License:          GNU GPL license (http://www.gnu.org/licenses/gpl.html)  
#
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

unset inputfastq
unset ref
unset blastresults 
unset full 
unset sam
unset bam 
plothistogram=""

#split input fasta file into blocks of size 1000 
blocksize=1000
#default number of blocks to use for the BLAST algorithm
defaultblocksforblast=5

array=( $@ ) 
numinputs=$#

for ((i=0; i<$numinputs; i++))
do
    if [ ${array[$i]} = -input ]
    then
	inputfastq=${array[$i+1]}
    fi
    if [ ${array[$i]} = -reference ] 
    then
	ref=${array[$i+1]}
    fi
    if [ ${array[$i]} = -blastresults ]
    then
	blastresults=${array[i+1]}
    fi
    if [ ${array[$i]} = -full ]
    then
	full=true
    fi
    if [ ${array[$i]} = -plothistogram ] 
    then
	plothistogram="-plothistogram"
    fi
    if [ ${array[$i]} = -sam ] 
    then
	sam=${array[i+1]}
	echo "sam file identified: $sam"
    fi
    if [ ${array[$i]} = -bam ] 
    then 
	bam=${array[i+1]}
	echo "bam file identified: $bam"
    fi
    
    
done
printhelp=false; 
if [[ -z "$inputfastq" ]]
then
    printhelp=true
elif [[ -z "$ref" ]]
then
    if [[ -z "$blastresults" ]] 
    then
	printhelp=true 
    fi
fi

if [ ${printhelp} = true ] 
then 
    echo "FASTQcharacterize can be used with the BLAST alignment tool or with an input SAM/BAM file generated by an external aligner"
    echo ""
    echo "To use with BLAST aligner:"
    echo ""
    echo "FASTQcharacterize.sh -input <input fastq file to characterize> -reference <.fasta reference file> "
    echo "options: "
    echo ""
    echo "-blastresults <blast results file> If a BLAST results file is specified, which might be preferred for speed purposes, the software will parse this input and use it as an input for dataset characterization" | fold -w 80
    echo "-reference This can be specified as an alternative to 'blastresults'. If specified, the software will run BLAST of the input fastq file against the input fasta reference" | fold -w 80
    echo "-full If a reference is provided and the -full flag is set, blast will be performed on the entire input fastq file. This can be slow, so by default only the first 5000 sequences of the input fastq file (or less) are used to perform blast against the reference dataset." | fold -w 80
    echo ""
    echo "To use with BAM/SAM input file:" 
    echo ""
    echo "FASTQcharacterize.sh -input <input fastq file to characterize > -reference <.fasta reference file> -bam[-sam] <.bam or .sam file > "
    echo ""
    echo "-plothistogram flag will cause histograms to be generated as the dataset is characterized." | fold -w 80
    exit
fi

echo "converting input fastq into fasta and quality files"
fasta=`echo $inputfastq | sed 's/.fastq/.fasta'/`
fasta=`echo $fasta | sed 's/.fq/.fasta'/`
qual=`echo $inputfastq | sed 's/.fastq/.qual'/`
qual=`echo $qual | sed 's/.fq/.qual'/`
basename=`echo $fasta | sed 's/.fasta/'/`
echo "fasta = $fasta"
echo "qual = $qual"
python src/fastq_extract.py $inputfastq
echo "complete" 
echo "getting read histogram..."

python src/readHist.py $fasta $plothistogram
echo "complete" 
echo "getting quality histogram..." 
python src/qualityHist.py $qual $plothistogram
echo "complete" 
readHistName=`echo $fasta | sed 's/.fasta/readHist.csv'/`
qualHistName=`echo $qual | sed 's/.qual/qualHist.csv'/`

#if a BAM file is specified, convert to sam 
if [[  -n "$bam" ]]
then
echo "converting input bam file to sam format" 
sam=`echo $bam | sed 's/.bam/.sam'/`
./samtools view $bam > $sam
fi

#annotate the matching bases and single base mutations in the sam file 
if [[ -n "$sam" ]] 
then 
echo "annotating single-base mutations in sam file"
sam_annotated=`echo $sam | sed 's/.sam/_annotated.sam'/`
echo "sam_annotated: $sam_annotated"
echo "sam: $sam" 
echo "reference: $ref"
./samtools calmd -e -S $sam $ref > $sam_annotated
echo "obtaining msa from sam file"
python src/msa_from_sam.py $sam_annotated $basename $plothistogram
echo "complete!"
fi

if [[ -z $sam ]]
then    
    if [[ -z "$blastresults" ]]
    then
	echo "splitting fasta into blocks"
	numblocks=`python src/fasta_blocks.py $fasta $blocksize`
	echo "complete" 
	echo "creating BLAST database"
	./makeblastdb -in $ref -dbtype nucl
    success=`echo $?`
    if [[ "$success" != "0" ]]
    then
	echo "makeblastdb failed to create BLAST databsae. Exiting now ..."
	exit;
    fi
    echo "complete" 
    if [[ -z "$full" ]]
    then
	if [[ $numblocks -gt $defaultblocksforblast ]]
	then
	    numblocks=$defaultblocksforblast
	fi
    fi
    for ((i=0; i<$numblocks; i++))
    do
	echo "running blast on input block $i ..."
	./blastn -num_alignments 10 -num_threads 2 -query $fasta\_$i -db $ref -out $basename\_b_$i.blast
	success=`echo $?`
	if [[ "$success" != "0" ]]
	then
	    echo "BLAST command failed. Exiting now ... "
	    exit
	fi
	echo "done"
	echo "Parsing blast block $i..."
	java -jar BlastParser.jar $basename\_b_$i.blast > $basename\_parsed.csv_$i
	echo "done" 
    done
    cat $basename\_parsed.csv_* > $basename\_parsed.csv
    else
    java -jar BlastParser.jar $blastresults > $basename\_parsed.csv
    fi
    python src/getBlastStats.py $fasta $basename\_parsed.csv $plothistogram
    echo "writing summary file for all statistics files generated" 
    summary=$basename\summary.csv
    rm $summary
    touch $summary
    echo "${basename}delCount.csv" >> $summary
    echo "${basename}delsByRead.csv" >> $summary
    echo "${basename}delSize.csv" >> $summary
    echo "${basename}insertCount.csv" >> $summary
    echo "${basename}insertsByRead.csv" >> $summary
    echo "${basename}insertSize.csv" >> $summary 
    echo "${basename}mutationCount.csv" >> $summary
    echo "${basename}mutationType.csv" >> $summary
    echo "${basename}posCount.csv" >> $summary
    echo "${basename}primerCheck.csv" >> $summary
    echo "${basename}qualHist.csv" >> $summary
    echo "${basename}readHist.csv" >> $summary 
    echo "${basename}Usage.csv" >> $summary 
fi
